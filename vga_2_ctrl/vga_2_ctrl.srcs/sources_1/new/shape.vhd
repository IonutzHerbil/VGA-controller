library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

PACKAGE MY IS
PROCEDURE SQ(SIGNAL Xcur,Ycur,Xpos,Ypos:IN INTEGER;SIGNAL DRAW_SQ: OUT STD_LOGIC);
PROCEDURE CIRCLE(SIGNAL Xcur,Ycur,Xpos,Ypos:IN INTEGER;SIGNAL DRAW_CIRC: OUT STD_LOGIC);
PROCEDURE SMILEY(SIGNAL Xcur,Ycur,Xpos,Ypos:IN INTEGER;SIGNAL DRAW_SMILEY: OUT STD_LOGIC);
PROCEDURE TRIANGLE(SIGNAL Xcur,Ycur,Xpos,Ypos:IN INTEGER;SIGNAL DRAW_TRI: OUT STD_LOGIC);
PROCEDURE ROMB(SIGNAL Xcur,Ycur,Xpos,Ypos:IN INTEGER;SIGNAL DRAW_ROMB: OUT STD_LOGIC);
PROCEDURE OCTOGON(SIGNAL Xcur,Ycur,Xpos,Ypos:IN INTEGER;SIGNAL DRAW_OCTOGON: OUT STD_LOGIC);
PROCEDURE DOUGHNUT(SIGNAL Xcur,Ycur,Xpos,Ypos:IN INTEGER;SIGNAL DRAW_DOUGH: OUT STD_LOGIC);
PROCEDURE STAR(SIGNAL Xcur,Ycur,Xpos,Ypos:IN INTEGER;SIGNAL DRAW_STAR: OUT STD_LOGIC);

END MY;

PACKAGE BODY MY IS
PROCEDURE SQ(SIGNAL Xcur,Ycur,Xpos,Ypos:IN INTEGER;SIGNAL DRAW_SQ: OUT STD_LOGIC) IS
BEGIN
 IF(Xcur>(Xpos-50) AND Xcur<(Xpos+50) AND Ycur>(Ypos-50) AND Ycur<(Ypos+50))THEN
	 DRAW_SQ<='1';
	 ELSE
	 DRAW_SQ<='0';
 END IF;
 
END SQ;

PROCEDURE CIRCLE(SIGNAL Xcur,Ycur,Xpos,Ypos:IN INTEGER;SIGNAL DRAW_CIRC: OUT STD_LOGIC) IS
BEGIN
    IF (XCUR-XPOS)*(XCUR-XPOS)+(YCUR-YPOS)*(YCUR-YPOS)<=2500 THEN
        DRAW_CIRC<='1';
       ELSE 
       DRAW_CIRC<='0';
    END IF;
END CIRCLE;    
    
PROCEDURE SMILEY(SIGNAL Xcur,Ycur,Xpos,Ypos:IN INTEGER;SIGNAL DRAW_SMILEY: OUT STD_LOGIC) IS
BEGIN
    IF (XCUR-XPOS)*(XCUR-XPOS)+(YCUR-YPOS)*(YCUR-YPOS)<=2500 THEN
        IF (YCUR>YPOS+20 AND  YCUR<YPOS+27 AND XCUR<XPOS+38 AND XCUR>XPOS-38)THEN
            DRAW_SMILEY<='0';
           ELSE
           IF (YCUR>YPOS-27 AND YCUR<YPOS-20 AND ((XCUR>XPOS-35 AND XCUR<XPOS-30)OR(XCUR<XPOS+35 AND XCUR>XPOS+30)) ) THEN
            DRAW_SMILEY<='0';
            ELSE 
            DRAW_SMILEY<='1';
            END IF; 
            END IF;
       ELSE 
       DRAW_SMILEY<='0';
    END IF;
    
END SMILEY;

PROCEDURE TRIANGLE (SIGNAL Xcur,Ycur,Xpos,Ypos:IN INTEGER;SIGNAL DRAW_TRI: OUT STD_LOGIC) is 
BEGIN
  IF(YCUR<YPOS+50 AND YCUR>YPOS-56 AND XCUR<XPOS+(50-YPOS+YCUR)/2 AND XCUR>XPOS+(-50+YPOS-YCUR)/2)THEN
    DRAW_TRI<='1';
ELSE
	 DRAW_TRI<='0';
 END IF;
 
END TRIANGLE;

PROCEDURE ROMB(SIGNAL Xcur, Ycur, Xpos, Ypos: IN INTEGER; SIGNAL DRAW_ROMB: OUT STD_LOGIC) IS
BEGIN
    IF(abs(Xcur-Xpos)+abs(Ycur-Ypos)<50) THEN
    DRAW_ROMB<='1';
ELSE
	 DRAW_ROMB<='0';
    END IF;
END ROMB;

PROCEDURE OCTOGON(SIGNAL Xcur,Ycur,Xpos,Ypos:IN INTEGER;SIGNAL DRAW_OCTOGON: OUT STD_LOGIC) is 
    BEGIN
IF(abs(Xcur-Xpos)+abs(Ycur-Ypos)<75 and Xcur<Xpos+50 and Xcur>Xpos-50 and Ycur<Ypos+50 and Ycur>Ypos-50) THEN
    DRAW_OCTOGON<='1';
ELSE
	 DRAW_OCTOGON<='0';
 END IF;

END OCTOGON;

PROCEDURE DOUGHNUT(SIGNAL Xcur,Ycur,Xpos,Ypos:IN INTEGER;SIGNAL DRAW_DOUGH: OUT STD_LOGIC) IS
BEGIN
    IF (XCUR-XPOS)*(XCUR-XPOS)+(YCUR-YPOS)*(YCUR-YPOS)<=2500 THEN
         IF (XCUR-XPOS)*(XCUR-XPOS)+(YCUR-YPOS)*(YCUR-YPOS)<=400 THEN
            DRAW_DOUGH<='0';
            ELSE
            DRAW_DOUGH<='1';
       END IF;
       ELSE 
       DRAW_DOUGH<='0';
    END IF;
END DOUGHNUT; 

PROCEDURE STAR (SIGNAL Xcur,Ycur,Xpos,Ypos:IN INTEGER;SIGNAL DRAW_STAR: OUT STD_LOGIC) is 
BEGIN
  IF((abs(Xcur-Xpos)+abs(Ycur-Ypos)<50)OR (Xcur>(Xpos-35) AND Xcur<(Xpos+35) AND Ycur>(Ypos-35) AND Ycur<(Ypos+35)) ) THEN
    DRAW_STAR<='1';
ELSE
	 DRAW_STAR<='0';
 END IF;
 
END STAR;


END MY;